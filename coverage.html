
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>components: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/anurag-roy/bubbletable/components/keybindings.go (100.0%)</option>
				
				<option value="file1">github.com/anurag-roy/bubbletable/components/model.go (65.9%)</option>
				
				<option value="file2">github.com/anurag-roy/bubbletable/examples/basic/main.go (0.0%)</option>
				
				<option value="file3">github.com/anurag-roy/bubbletable/examples/custom_theme/main.go (0.0%)</option>
				
				<option value="file4">github.com/anurag-roy/bubbletable/examples/headless/main.go (0.0%)</option>
				
				<option value="file5">github.com/anurag-roy/bubbletable/main.go (0.0%)</option>
				
				<option value="file6">github.com/anurag-roy/bubbletable/renderer/renderer.go (68.8%)</option>
				
				<option value="file7">github.com/anurag-roy/bubbletable/renderer/themes.go (28.6%)</option>
				
				<option value="file8">github.com/anurag-roy/bubbletable/table/data.go (64.6%)</option>
				
				<option value="file9">github.com/anurag-roy/bubbletable/table/formatters.go (98.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package components

// KeyBindings represents configurable key bindings for table interactions
type KeyBindings struct {
        Up           []string
        Down         []string
        Left         []string
        Right        []string
        PageUp       []string
        PageDown     []string
        Home         []string
        End          []string
        Search       []string
        Sort         map[int][]string // Column index to keys
        Quit         []string
        Help         []string
        Refresh      []string
        PageSizeUp   []string
        PageSizeDown []string
        ResetPage    []string
        ClearSort    []string
}

// DefaultKeyBindings returns the default key bindings
func DefaultKeyBindings() KeyBindings <span class="cov8" title="1">{
        return KeyBindings{
                Up:       []string{"up", "k"},
                Down:     []string{"down", "j"},
                Left:     []string{"left", "h", "p"},
                Right:    []string{"right", "l", "n"},
                PageUp:   []string{"pageup", "ctrl+b"},
                PageDown: []string{"pagedown", "ctrl+f"},
                Home:     []string{"home", "g"},
                End:      []string{"end", "G"},
                Search:   []string{"/"},
                Sort: map[int][]string{
                        0: {"1"},
                        1: {"2"},
                        2: {"3"},
                        3: {"4"},
                        4: {"5"},
                        5: {"6"},
                        6: {"7"},
                        7: {"8"},
                        8: {"9"},
                },
                Quit:         []string{"q", "esc", "ctrl+c"},
                Help:         []string{"?", "h"},
                Refresh:      []string{"r"},
                PageSizeUp:   []string{"+", "="},
                PageSizeDown: []string{"-", "_"},
                ResetPage:    []string{"r"},
                ClearSort:    []string{"c"},
        }
}</span>

// VimKeyBindings returns vim-style key bindings
func VimKeyBindings() KeyBindings <span class="cov8" title="1">{
        bindings := DefaultKeyBindings()
        bindings.Up = []string{"k", "up"}
        bindings.Down = []string{"j", "down"}
        bindings.Left = []string{"h", "left"}
        bindings.Right = []string{"l", "right"}
        bindings.Home = []string{"gg", "home"}
        bindings.End = []string{"G", "end"}
        bindings.PageUp = []string{"ctrl+u", "pageup"}
        bindings.PageDown = []string{"ctrl+d", "pagedown"}
        return bindings
}</span>

// EmacsKeyBindings returns emacs-style key bindings
func EmacsKeyBindings() KeyBindings <span class="cov8" title="1">{
        bindings := DefaultKeyBindings()
        bindings.Up = []string{"ctrl+p", "up"}
        bindings.Down = []string{"ctrl+n", "down"}
        bindings.Left = []string{"ctrl+b", "left"}
        bindings.Right = []string{"ctrl+f", "right"}
        bindings.Home = []string{"ctrl+a", "home"}
        bindings.End = []string{"ctrl+e", "end"}
        bindings.Search = []string{"ctrl+s", "/"}
        return bindings
}</span>

// matchesKey checks if a key string matches any of the configured keys
func (kb KeyBindings) matchesKey(key string, keys []string) bool <span class="cov8" title="1">{
        for _, k := range keys </span><span class="cov8" title="1">{
                if k == key </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsUp checks if the key is an up navigation key
func (kb KeyBindings) IsUp(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Up)
}</span>

// IsDown checks if the key is a down navigation key
func (kb KeyBindings) IsDown(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Down)
}</span>

// IsLeft checks if the key is a left navigation key
func (kb KeyBindings) IsLeft(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Left)
}</span>

// IsRight checks if the key is a right navigation key
func (kb KeyBindings) IsRight(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Right)
}</span>

// IsPageUp checks if the key is a page up key
func (kb KeyBindings) IsPageUp(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.PageUp)
}</span>

// IsPageDown checks if the key is a page down key
func (kb KeyBindings) IsPageDown(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.PageDown)
}</span>

// IsHome checks if the key is a home key
func (kb KeyBindings) IsHome(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Home)
}</span>

// IsEnd checks if the key is an end key
func (kb KeyBindings) IsEnd(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.End)
}</span>

// IsSearch checks if the key is a search key
func (kb KeyBindings) IsSearch(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Search)
}</span>

// IsQuit checks if the key is a quit key
func (kb KeyBindings) IsQuit(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Quit)
}</span>

// IsHelp checks if the key is a help key
func (kb KeyBindings) IsHelp(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Help)
}</span>

// IsRefresh checks if the key is a refresh key
func (kb KeyBindings) IsRefresh(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.Refresh)
}</span>

// IsPageSizeUp checks if the key increases page size
func (kb KeyBindings) IsPageSizeUp(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.PageSizeUp)
}</span>

// IsPageSizeDown checks if the key decreases page size
func (kb KeyBindings) IsPageSizeDown(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.PageSizeDown)
}</span>

// IsResetPage checks if the key resets to optimal page size
func (kb KeyBindings) IsResetPage(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.ResetPage)
}</span>

// IsClearSort checks if the key clears sorting
func (kb KeyBindings) IsClearSort(key string) bool <span class="cov8" title="1">{
        return kb.matchesKey(key, kb.ClearSort)
}</span>

// GetSortColumn returns the column index for sorting, or -1 if not a sort key
func (kb KeyBindings) GetSortColumn(key string) int <span class="cov8" title="1">{
        for colIndex, keys := range kb.Sort </span><span class="cov8" title="1">{
                if kb.matchesKey(key, keys) </span><span class="cov8" title="1">{
                        return colIndex
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package components

import (
        "fmt"
        "strings"

        "github.com/anurag-roy/bubbletable/renderer"
        "github.com/anurag-roy/bubbletable/table"
        tea "github.com/charmbracelet/bubbletea"
)

// TableModel represents the Bubble Tea model for the table component
type TableModel struct {
        table         *table.Table
        filteredTable *table.Table
        renderer      *renderer.TableRenderer

        // State
        ready       bool
        currentPage int
        selectedRow int
        searchMode  bool
        searchTerm  string

        // Configuration
        keyBindings KeyBindings
        theme       renderer.Theme
        pageSize    int
        showHelp    bool

        // Callbacks
        onSelect  func(row table.Row)
        onSort    func(columnIndex int, desc bool)
        onSearch  func(term string)
        onRefresh func()

        // Dimensions
        width  int
        height int
}

// NewTable creates a new table model from a slice of data
func NewTable[T any](data []T) *TableModel <span class="cov8" title="1">{
        // Convert slice to interface{} slice
        interfaceData := make([]interface{}, len(data))
        for i, item := range data </span><span class="cov8" title="1">{
                interfaceData[i] = item
        }</span>

        <span class="cov8" title="1">return NewTableFromInterface(interfaceData)</span>
}

// NewTableFromInterface creates a new table model from interface{} data
func NewTableFromInterface(data []interface{}) *TableModel <span class="cov8" title="1">{
        tbl := table.New()
        if len(data) &gt; 0 </span><span class="cov8" title="1">{
                tbl.SetData(data)
        }</span>

        <span class="cov8" title="1">return &amp;TableModel{
                table:         tbl,
                filteredTable: nil,
                renderer:      renderer.NewTableRenderer(80, 24),
                keyBindings:   DefaultKeyBindings(),
                theme:         renderer.DefaultTheme,
                pageSize:      10,
                currentPage:   0,
                selectedRow:   0,
                searchMode:    false,
                searchTerm:    "",
                ready:         false,
                showHelp:      false,
        }</span>
}

// NewTableWithColumns creates a new table model with predefined columns
func NewTableWithColumns(data []map[string]interface{}, columns []table.Column) *TableModel <span class="cov8" title="1">{
        tbl := table.NewWithColumns(columns)

        // Convert data to interface{} slice
        interfaceData := make([]interface{}, len(data))
        for i, item := range data </span><span class="cov8" title="1">{
                interfaceData[i] = item
        }</span>

        <span class="cov8" title="1">tbl.SetData(interfaceData)

        return &amp;TableModel{
                table:         tbl,
                filteredTable: nil,
                renderer:      renderer.NewTableRenderer(80, 24),
                keyBindings:   DefaultKeyBindings(),
                theme:         renderer.DefaultTheme,
                pageSize:      10,
                currentPage:   0,
                selectedRow:   0,
                searchMode:    false,
                searchTerm:    "",
                ready:         false,
                showHelp:      false,
        }</span>
}

// Builder pattern methods for configuration

// WithPageSize sets the page size
func (m *TableModel) WithPageSize(size int) *TableModel <span class="cov8" title="1">{
        m.pageSize = size
        if m.table != nil </span><span class="cov8" title="1">{
                m.table.PageSize = size
        }</span>
        <span class="cov8" title="1">return m</span>
}

// WithTheme sets the theme
func (m *TableModel) WithTheme(theme renderer.Theme) *TableModel <span class="cov8" title="1">{
        m.theme = theme
        if m.renderer != nil </span><span class="cov8" title="1">{
                m.renderer.SetTheme(theme)
        }</span>
        <span class="cov8" title="1">return m</span>
}

// WithKeyBindings sets custom key bindings
func (m *TableModel) WithKeyBindings(bindings KeyBindings) *TableModel <span class="cov8" title="1">{
        m.keyBindings = bindings
        return m
}</span>

// WithSorting enables or disables sorting
func (m *TableModel) WithSorting(enabled bool) *TableModel <span class="cov8" title="1">{
        if m.table != nil </span><span class="cov8" title="1">{
                for i := range m.table.Columns </span><span class="cov8" title="1">{
                        m.table.Columns[i].Sortable = enabled
                }</span>
        }
        <span class="cov8" title="1">return m</span>
}

// WithSearch enables or disables search
func (m *TableModel) WithSearch(enabled bool) *TableModel <span class="cov8" title="1">{
        if m.table != nil </span><span class="cov8" title="1">{
                for i := range m.table.Columns </span><span class="cov8" title="1">{
                        m.table.Columns[i].Searchable = enabled
                }</span>
        }
        <span class="cov8" title="1">return m</span>
}

// WithOnSelect sets a callback for row selection
func (m *TableModel) WithOnSelect(callback func(row table.Row)) *TableModel <span class="cov8" title="1">{
        m.onSelect = callback
        return m
}</span>

// WithOnSort sets a callback for sorting changes
func (m *TableModel) WithOnSort(callback func(columnIndex int, desc bool)) *TableModel <span class="cov8" title="1">{
        m.onSort = callback
        return m
}</span>

// WithOnSearch sets a callback for search changes
func (m *TableModel) WithOnSearch(callback func(term string)) *TableModel <span class="cov8" title="1">{
        m.onSearch = callback
        return m
}</span>

// WithOnRefresh sets a callback for refresh requests
func (m *TableModel) WithOnRefresh(callback func()) *TableModel <span class="cov8" title="1">{
        m.onRefresh = callback
        return m
}</span>

// Bubble Tea interface implementation

// Init initializes the model
func (m *TableModel) Init() tea.Cmd <span class="cov8" title="1">{
        return nil
}</span>

// Update handles messages and updates the model
func (m *TableModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov8" title="1">
                m.width = msg.Width
                m.height = msg.Height
                m.ready = true

                if m.renderer != nil </span><span class="cov8" title="1">{
                        m.renderer.UpdateSize(msg.Width, msg.Height)
                }</span>

                // Optimize page size for terminal
                <span class="cov8" title="1">if m.pageSize == 10 </span><span class="cov8" title="1">{ // Only adjust if using default
                        optimalSize := m.renderer.GetOptimalPageSize()
                        m.pageSize = optimalSize
                        if m.table != nil </span><span class="cov8" title="1">{
                                m.table.PageSize = optimalSize
                        }</span>
                }

                <span class="cov8" title="1">return m, nil</span>

        case tea.KeyMsg:<span class="cov8" title="1">
                return m.handleKeyPress(msg)</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// handleKeyPress handles key press events
func (m *TableModel) handleKeyPress(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        key := msg.String()

        // Handle search mode input
        if m.searchMode </span><span class="cov8" title="1">{
                return m.handleSearchInput(key)
        }</span>

        // Handle normal mode keys
        <span class="cov8" title="1">switch </span>{
        case m.keyBindings.IsQuit(key):<span class="cov0" title="0">
                return m, tea.Quit</span>

        case m.keyBindings.IsUp(key):<span class="cov0" title="0">
                if m.selectedRow &gt; 0 </span><span class="cov0" title="0">{
                        m.selectedRow--
                }</span>

        case m.keyBindings.IsDown(key):<span class="cov0" title="0">
                currentTable := m.getCurrentTable()
                if currentTable != nil </span><span class="cov0" title="0">{
                        pageData := currentTable.GetPage(m.currentPage)
                        if m.selectedRow &lt; len(pageData)-1 </span><span class="cov0" title="0">{
                                m.selectedRow++
                        }</span>
                }

        case m.keyBindings.IsLeft(key) || m.keyBindings.IsPageUp(key):<span class="cov8" title="1">
                if m.currentPage &gt; 0 </span><span class="cov8" title="1">{
                        m.currentPage--
                        m.selectedRow = 0
                }</span>

        case m.keyBindings.IsRight(key) || m.keyBindings.IsPageDown(key):<span class="cov8" title="1">
                currentTable := m.getCurrentTable()
                if currentTable != nil &amp;&amp; m.currentPage &lt; currentTable.GetTotalPages()-1 </span><span class="cov8" title="1">{
                        m.currentPage++
                        m.selectedRow = 0
                }</span>

        case m.keyBindings.IsHome(key):<span class="cov0" title="0">
                m.currentPage = 0
                m.selectedRow = 0</span>

        case m.keyBindings.IsEnd(key):<span class="cov0" title="0">
                currentTable := m.getCurrentTable()
                if currentTable != nil </span><span class="cov0" title="0">{
                        m.currentPage = currentTable.GetTotalPages() - 1
                        m.selectedRow = 0
                }</span>

        case m.keyBindings.IsSearch(key):<span class="cov8" title="1">
                m.searchMode = true
                m.searchTerm = ""</span>

        case m.keyBindings.IsPageSizeUp(key):<span class="cov0" title="0">
                m.adjustPageSize(m.pageSize + 5)</span>

        case m.keyBindings.IsPageSizeDown(key):<span class="cov0" title="0">
                newSize := m.pageSize - 5
                if newSize &lt; 5 </span><span class="cov0" title="0">{
                        newSize = 5
                }</span>
                <span class="cov0" title="0">m.adjustPageSize(newSize)</span>

        case m.keyBindings.IsResetPage(key):<span class="cov0" title="0">
                if m.renderer != nil </span><span class="cov0" title="0">{
                        optimalSize := m.renderer.GetOptimalPageSize()
                        m.adjustPageSize(optimalSize)
                }</span>

        case m.keyBindings.IsClearSort(key):<span class="cov0" title="0">
                if m.table != nil </span><span class="cov0" title="0">{
                        m.table.ClearSort()
                        m.currentPage = 0
                        m.selectedRow = 0
                }</span>

        case m.keyBindings.IsHelp(key):<span class="cov0" title="0">
                m.showHelp = !m.showHelp</span>

        case m.keyBindings.IsRefresh(key):<span class="cov0" title="0">
                if m.onRefresh != nil </span><span class="cov0" title="0">{
                        m.onRefresh()
                }</span>

        default:<span class="cov8" title="1">
                // Check for sort keys
                if colIndex := m.keyBindings.GetSortColumn(key); colIndex &gt;= 0 &amp;&amp; m.table != nil </span><span class="cov8" title="1">{
                        if colIndex &lt; len(m.table.Columns) </span><span class="cov8" title="1">{
                                // Three-state sorting: unsorted -&gt; asc -&gt; desc -&gt; unsorted
                                if m.table.SortBy == colIndex </span><span class="cov0" title="0">{
                                        if !m.table.SortDesc </span><span class="cov0" title="0">{
                                                m.table.SortByColumn(colIndex, true)
                                        }</span> else<span class="cov0" title="0"> {
                                                m.table.ClearSort()
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        m.table.SortByColumn(colIndex, false)
                                }</span>

                                <span class="cov8" title="1">m.currentPage = 0
                                m.selectedRow = 0

                                if m.onSort != nil </span><span class="cov0" title="0">{
                                        m.onSort(colIndex, m.table.SortDesc)
                                }</span>
                        }
                }
        }

        // Trigger selection callback if we have one
        <span class="cov8" title="1">if m.onSelect != nil </span><span class="cov0" title="0">{
                currentTable := m.getCurrentTable()
                if currentTable != nil </span><span class="cov0" title="0">{
                        pageData := currentTable.GetPage(m.currentPage)
                        if m.selectedRow &lt; len(pageData) </span><span class="cov0" title="0">{
                                m.onSelect(pageData[m.selectedRow])
                        }</span>
                }
        }

        <span class="cov8" title="1">return m, nil</span>
}

// handleSearchInput handles input during search mode
func (m *TableModel) handleSearchInput(key string) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch key </span>{
        case "esc":<span class="cov0" title="0">
                m.searchMode = false
                m.searchTerm = ""
                m.filteredTable = nil
                m.currentPage = 0
                m.selectedRow = 0</span>

        case "backspace":<span class="cov0" title="0">
                if len(m.searchTerm) &gt; 0 </span><span class="cov0" title="0">{
                        m.searchTerm = m.searchTerm[:len(m.searchTerm)-1]
                        m.updateSearch()
                }</span>

        case "enter":<span class="cov8" title="1">
                m.searchMode = false</span>

        default:<span class="cov8" title="1">
                // Handle character input
                if len(key) == 1 </span><span class="cov8" title="1">{
                        char := key[0]
                        if char &gt;= 32 &amp;&amp; char &lt;= 126 </span><span class="cov8" title="1">{ // Printable ASCII
                                m.searchTerm += key
                                m.updateSearch()
                        }</span>
                }
        }

        <span class="cov8" title="1">return m, nil</span>
}

// updateSearch updates the filtered table based on search term
func (m *TableModel) updateSearch() <span class="cov8" title="1">{
        if m.table == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if m.searchTerm == "" </span><span class="cov0" title="0">{
                m.filteredTable = nil
        }</span> else<span class="cov8" title="1"> {
                m.filteredTable = m.table.Filter(m.searchTerm)
        }</span>

        <span class="cov8" title="1">m.currentPage = 0
        m.selectedRow = 0

        if m.onSearch != nil </span><span class="cov0" title="0">{
                m.onSearch(m.searchTerm)
        }</span>
}

// adjustPageSize adjusts the page size and recalculates pages
func (m *TableModel) adjustPageSize(newSize int) <span class="cov0" title="0">{
        m.pageSize = newSize
        if m.table != nil </span><span class="cov0" title="0">{
                m.table.PageSize = newSize
        }</span>
        <span class="cov0" title="0">if m.filteredTable != nil </span><span class="cov0" title="0">{
                m.filteredTable.PageSize = newSize
        }</span>

        // Reset to first page to avoid being out of bounds
        <span class="cov0" title="0">m.currentPage = 0
        m.selectedRow = 0</span>
}

// getCurrentTable returns the current table (filtered or main)
func (m *TableModel) getCurrentTable() *table.Table <span class="cov8" title="1">{
        if m.filteredTable != nil </span><span class="cov0" title="0">{
                return m.filteredTable
        }</span>
        <span class="cov8" title="1">return m.table</span>
}

// View renders the table
func (m *TableModel) View() string <span class="cov8" title="1">{
        if !m.ready </span><span class="cov8" title="1">{
                return "Loading..."
        }</span>

        <span class="cov8" title="1">if m.showHelp </span><span class="cov0" title="0">{
                return m.renderHelp()
        }</span>

        <span class="cov8" title="1">var content strings.Builder

        // Title
        title := m.theme.Header.Render("Data Table")
        content.WriteString(title + "\n\n")

        // Table content
        currentTable := m.getCurrentTable()
        if currentTable != nil &amp;&amp; m.renderer != nil </span><span class="cov8" title="1">{
                tableContent := m.renderer.RenderTable(currentTable, m.currentPage, m.selectedRow)
                content.WriteString(tableContent)
        }</span> else<span class="cov0" title="0"> {
                content.WriteString("No data available")
        }</span>

        <span class="cov8" title="1">content.WriteString("\n\n")

        // Status bar
        content.WriteString(m.renderStatusBar())

        // Search bar
        if m.searchMode </span><span class="cov0" title="0">{
                content.WriteString("\n")
                searchText := fmt.Sprintf("Search: %s", m.searchTerm)
                content.WriteString(m.theme.Search.Render(searchText))
        }</span>

        <span class="cov8" title="1">return content.String()</span>
}

// renderStatusBar renders the status bar with navigation info
func (m *TableModel) renderStatusBar() string <span class="cov8" title="1">{
        currentTable := m.getCurrentTable()
        if currentTable == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">totalPages := currentTable.GetTotalPages()
        startRow := m.currentPage*m.pageSize + 1
        pageData := currentTable.GetPage(m.currentPage)
        endRow := startRow + len(pageData) - 1

        if len(pageData) == 0 </span><span class="cov8" title="1">{
                startRow = 0
                endRow = 0
        }</span>

        <span class="cov8" title="1">status := fmt.Sprintf("Page %d/%d | Rows %d-%d of %d | Page Size: %d",
                m.currentPage+1, totalPages, startRow, endRow, currentTable.TotalRows, m.pageSize)

        // Add sort info
        if currentTable.SortBy &gt;= 0 &amp;&amp; currentTable.SortBy &lt; len(currentTable.Columns) </span><span class="cov0" title="0">{
                sortDir := "↑"
                if currentTable.SortDesc </span><span class="cov0" title="0">{
                        sortDir = "↓"
                }</span>
                <span class="cov0" title="0">status += fmt.Sprintf(" | Sort: %s %s", currentTable.Columns[currentTable.SortBy].Header, sortDir)</span>
        }

        // Add search info
        <span class="cov8" title="1">if m.searchTerm != "" </span><span class="cov0" title="0">{
                status += fmt.Sprintf(" | Search: '%s'", m.searchTerm)
        }</span>

        <span class="cov8" title="1">return m.theme.Status.Render(status)</span>
}

// renderHelp renders the help screen
func (m *TableModel) renderHelp() string <span class="cov0" title="0">{
        help := `
Table Navigation Help

Navigation:
  ↑/k         - Move up
  ↓/j         - Move down  
  ←/h         - Previous page
  →/l         - Next page
  Home/g      - First page
  End/G       - Last page

Sorting:
  1-9         - Sort by column (press again to reverse, third time to clear)
  c           - Clear sort

Search:
  /           - Enter search mode
  ESC         - Exit search mode
  Backspace   - Delete search characters

Page Size:
  +/=         - Increase page size
  -/_         - Decrease page size
  r           - Reset to optimal page size

Other:
  ?           - Toggle this help
  q/ESC/Ctrl+C - Quit

Press ? again to return to the table.
`

        return m.theme.Cell.Render(help)
}</span>

// GetTable returns the underlying table (for advanced usage)
func (m *TableModel) GetTable() *table.Table <span class="cov8" title="1">{
        return m.table
}</span>

// GetCurrentTable returns the currently displayed table (filtered or main)
func (m *TableModel) GetCurrentTable() *table.Table <span class="cov8" title="1">{
        return m.getCurrentTable()
}</span>

// GetSelectedRow returns the currently selected row
func (m *TableModel) GetSelectedRow() (table.Row, bool) <span class="cov8" title="1">{
        currentTable := m.getCurrentTable()
        if currentTable == nil </span><span class="cov0" title="0">{
                return table.Row{}, false
        }</span>

        <span class="cov8" title="1">pageData := currentTable.GetPage(m.currentPage)
        if m.selectedRow &gt;= len(pageData) </span><span class="cov8" title="1">{
                return table.Row{}, false
        }</span>

        <span class="cov8" title="1">return pageData[m.selectedRow], true</span>
}

// SetData updates the table data
func (m *TableModel) SetData(data interface{}) error <span class="cov8" title="1">{
        if m.table == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("table not initialized")
        }</span>

        // Reset state
        <span class="cov8" title="1">m.currentPage = 0
        m.selectedRow = 0
        m.searchTerm = ""
        m.filteredTable = nil

        return m.table.SetData(data)</span>
}

// RefreshData refreshes the table data (useful for live updates)
func (m *TableModel) RefreshData(data interface{}) error <span class="cov8" title="1">{
        // Preserve current state
        currentPage := m.currentPage
        selectedRow := m.selectedRow
        searchTerm := m.searchTerm

        // Update data
        err := m.SetData(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Restore state if possible
        <span class="cov8" title="1">if m.table != nil </span><span class="cov8" title="1">{
                maxPages := m.table.GetTotalPages()
                if currentPage &lt; maxPages </span><span class="cov8" title="1">{
                        m.currentPage = currentPage
                }</span>

                <span class="cov8" title="1">pageData := m.table.GetPage(m.currentPage)
                if selectedRow &lt; len(pageData) </span><span class="cov8" title="1">{
                        m.selectedRow = selectedRow
                }</span>

                // Restore search if there was one
                <span class="cov8" title="1">if searchTerm != "" </span><span class="cov0" title="0">{
                        m.searchTerm = searchTerm
                        m.updateSearch()
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "log"

        "github.com/anurag-roy/bubbletable/components"
        "github.com/anurag-roy/bubbletable/table"
        tea "github.com/charmbracelet/bubbletea"
)

// Employee represents a sample employee struct with table tags
type Employee struct {
        ID         int     `table:"ID,sortable,width:5"`
        Name       string  `table:"Name,sortable,width:20"`
        Department string  `table:"Department,sortable,width:15"`
        Salary     float64 `table:"Salary,sortable,width:12,format:currency"`
        StartDate  string  `table:"Start Date,sortable,width:12,format:date"`
        Active     bool    `table:"Active,sortable,width:8"`
}

func main() <span class="cov0" title="0">{
        // Sample data
        employees := []Employee{
                {1, "Alice Johnson", "Engineering", 75000.0, "2021-01-15", true},
                {2, "Bob Smith", "Marketing", 65000.0, "2020-03-20", true},
                {3, "Charlie Brown", "Sales", 55000.0, "2019-11-10", false},
                {4, "Diana Prince", "Engineering", 85000.0, "2021-06-01", true},
                {5, "Edward Norton", "Finance", 70000.0, "2020-08-15", true},
                {6, "Fiona Apple", "Design", 68000.0, "2021-02-28", true},
                {7, "George Lucas", "Engineering", 95000.0, "2018-12-01", true},
                {8, "Helen Troy", "HR", 62000.0, "2020-09-15", true},
                {9, "Ivan Drago", "Sales", 58000.0, "2019-07-20", true},
                {10, "Julia Roberts", "Marketing", 72000.0, "2021-04-10", true},
                {11, "Kevin Hart", "Engineering", 78000.0, "2020-11-25", true},
                {12, "Luna Lovegood", "Design", 64000.0, "2021-01-30", true},
                {13, "Mike Tyson", "Operations", 66000.0, "2020-05-12", true},
                {14, "Nancy Drew", "Legal", 88000.0, "2019-03-08", true},
                {15, "Oscar Wilde", "Marketing", 69000.0, "2020-10-22", false},
        }

        // Create table model with fluent API
        tableModel := components.NewTable(employees).
                WithPageSize(10).
                WithSorting(true).
                WithSearch(true).
                WithOnSelect(func(row table.Row) </span>{<span class="cov0" title="0">
                        // Optional: Handle row selection
                        // log.Printf("Selected row: %+v", row)
                }</span>)

        // Create and run the Bubble Tea program
        <span class="cov0" title="0">p := tea.NewProgram(tableModel, tea.WithAltScreen())
        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "log"

        "github.com/anurag-roy/bubbletable/components"
        "github.com/anurag-roy/bubbletable/renderer"
        "github.com/anurag-roy/bubbletable/table"
        tea "github.com/charmbracelet/bubbletea"
)

// Product represents a sample product struct
type Product struct {
        SKU       string  `table:"SKU,sortable,width:10"`
        Name      string  `table:"Product Name,sortable,width:25"`
        Category  string  `table:"Category,sortable,width:15"`
        Price     float64 `table:"Price,sortable,width:10,format:currency"`
        Stock     int     `table:"Stock,sortable,width:8"`
        Available bool    `table:"Available,sortable,width:10"`
}

func main() <span class="cov0" title="0">{
        // Sample product data
        products := []Product{
                {"SKU-001", "Wireless Headphones", "Electronics", 99.99, 50, true},
                {"SKU-002", "Smart Watch", "Electronics", 249.99, 25, true},
                {"SKU-003", "Laptop Stand", "Accessories", 35.99, 100, true},
                {"SKU-004", "USB-C Cable", "Accessories", 12.99, 200, true},
                {"SKU-005", "Mechanical Keyboard", "Electronics", 129.99, 0, false},
                {"SKU-006", "Gaming Mouse", "Electronics", 69.99, 75, true},
                {"SKU-007", "Monitor", "Electronics", 299.99, 15, true},
                {"SKU-008", "Desk Lamp", "Furniture", 45.99, 30, true},
                {"SKU-009", "Phone Case", "Accessories", 19.99, 150, true},
                {"SKU-010", "Tablet Stand", "Accessories", 28.99, 80, true},
                {"SKU-011", "Webcam", "Electronics", 89.99, 40, true},
                {"SKU-012", "Microphone", "Electronics", 159.99, 20, true},
                {"SKU-013", "Speaker Set", "Electronics", 199.99, 35, true},
                {"SKU-014", "Power Bank", "Electronics", 39.99, 60, true},
                {"SKU-015", "Charging Pad", "Electronics", 29.99, 90, true},
        }

        // Create custom columns with renderers
        columns := []table.Column{
                *table.NewColumn("SKU", "SKU").
                        WithType(table.String).
                        WithWidth(10).
                        WithSortable(true),
                *table.NewColumn("Name", "Product Name").
                        WithType(table.String).
                        WithWidth(25).
                        WithSortable(true).
                        WithRenderer(func(val interface{}, selected bool) string </span><span class="cov0" title="0">{
                                return fmt.Sprintf("📦 %s", val)
                        }</span>),
                *table.NewColumn("Category", "Category").
                        WithType(table.String).
                        WithWidth(15).
                        WithSortable(true),
                *table.NewColumn("Price", "Price").
                        WithType(table.Float).
                        WithWidth(10).
                        WithSortable(true).
                        WithFormatter(table.CurrencyFormatter),
                *table.NewColumn("Stock", "Stock").
                        WithType(table.Integer).
                        WithWidth(8).
                        WithSortable(true).
                        WithRenderer(func(val interface{}, selected bool) string <span class="cov0" title="0">{
                                stock := val.(int)
                                if stock == 0 </span><span class="cov0" title="0">{
                                        return "❌ 0"
                                }</span> else<span class="cov0" title="0"> if stock &lt; 30 </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("⚠️ %d", stock)
                                }</span>
                                <span class="cov0" title="0">return fmt.Sprintf("✅ %d", stock)</span>
                        }),
                *table.NewColumn("Available", "Available").
                        WithType(table.Boolean).
                        WithWidth(10).
                        WithSortable(true).
                        WithFormatter(table.BooleanFormatter("✅ Yes", "❌ No")),
        }

        // Convert products to map format for custom columns
        <span class="cov0" title="0">data := make([]map[string]interface{}, len(products))
        for i, p := range products </span><span class="cov0" title="0">{
                data[i] = map[string]interface{}{
                        "SKU":       p.SKU,
                        "Name":      p.Name,
                        "Category":  p.Category,
                        "Price":     p.Price,
                        "Stock":     p.Stock,
                        "Available": p.Available,
                }
        }</span>

        // Create table with custom theme and configuration
        <span class="cov0" title="0">tableModel := components.NewTableWithColumns(data, columns).
                WithPageSize(12).
                WithTheme(renderer.DraculaTheme).
                WithKeyBindings(components.VimKeyBindings()).
                WithSorting(true).
                WithSearch(true).
                WithOnSelect(func(row table.Row) </span><span class="cov0" title="0">{
                        // Handle product selection
                        fmt.Printf("Selected product: %s\n", row.Cells[0].Value)
                }</span>).
                WithOnSort(func(columnIndex int, desc bool) <span class="cov0" title="0">{
                        direction := "ascending"
                        if desc </span><span class="cov0" title="0">{
                                direction = "descending"
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("Sorted by column %d (%s)\n", columnIndex, direction)</span>
                }).
                WithOnSearch(func(term string) <span class="cov0" title="0">{
                        if term != "" </span><span class="cov0" title="0">{
                                fmt.Printf("Searching for: %s\n", term)
                        }</span>
                })

        // Create and run the program
        <span class="cov0" title="0">p := tea.NewProgram(tableModel, tea.WithAltScreen())
        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "log"
        "strings"

        "github.com/anurag-roy/bubbletable/table"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// CustomModel demonstrates headless usage with full control over rendering
type CustomModel struct {
        table       *table.Table
        currentPage int
        selectedRow int
}

// Sample data structure
type Task struct {
        ID        int    `table:"ID,sortable,width:5"`
        Title     string `table:"Title,sortable,width:30"`
        Status    string `table:"Status,sortable,width:12"`
        Priority  string `table:"Priority,sortable,width:10"`
        Assignee  string `table:"Assignee,sortable,width:15"`
        Completed bool   `table:"Done,sortable,width:6"`
}

func NewCustomModel() *CustomModel <span class="cov0" title="0">{
        // Create sample tasks
        tasks := []Task{
                {1, "Implement user authentication", "In Progress", "High", "Alice", false},
                {2, "Design database schema", "Completed", "Medium", "Bob", true},
                {3, "Write API documentation", "Todo", "Low", "Charlie", false},
                {4, "Set up CI/CD pipeline", "In Progress", "High", "Diana", false},
                {5, "Create unit tests", "Todo", "Medium", "Edward", false},
                {6, "Optimize database queries", "Completed", "High", "Fiona", true},
                {7, "Implement caching layer", "In Progress", "Medium", "George", false},
                {8, "Fix security vulnerabilities", "Todo", "Critical", "Helen", false},
                {9, "Update user interface", "In Progress", "Low", "Ivan", false},
                {10, "Deploy to production", "Todo", "Critical", "Julia", false},
        }

        // Create headless table with custom configuration
        tbl := table.New().
                WithData(tasks).
                WithPageSize(5)

        // Customize columns with custom formatters
        for i, col := range tbl.Columns </span><span class="cov0" title="0">{
                switch col.Key </span>{
                case "Status":<span class="cov0" title="0">
                        tbl.Columns[i].Formatter = func(value interface{}) string </span><span class="cov0" title="0">{
                                status := value.(string)
                                switch status </span>{
                                case "Completed":<span class="cov0" title="0">
                                        return "✅ " + status</span>
                                case "In Progress":<span class="cov0" title="0">
                                        return "🔄 " + status</span>
                                case "Todo":<span class="cov0" title="0">
                                        return "📋 " + status</span>
                                default:<span class="cov0" title="0">
                                        return status</span>
                                }
                        }
                case "Priority":<span class="cov0" title="0">
                        tbl.Columns[i].Formatter = func(value interface{}) string </span><span class="cov0" title="0">{
                                priority := value.(string)
                                switch priority </span>{
                                case "Critical":<span class="cov0" title="0">
                                        return "🔴 " + priority</span>
                                case "High":<span class="cov0" title="0">
                                        return "🟠 " + priority</span>
                                case "Medium":<span class="cov0" title="0">
                                        return "🟡 " + priority</span>
                                case "Low":<span class="cov0" title="0">
                                        return "🟢 " + priority</span>
                                default:<span class="cov0" title="0">
                                        return priority</span>
                                }
                        }
                case "Completed":<span class="cov0" title="0">
                        tbl.Columns[i].Formatter = table.BooleanFormatter("✅", "❌")</span>
                }
        }

        <span class="cov0" title="0">return &amp;CustomModel{
                table:       tbl,
                currentPage: 0,
                selectedRow: 0,
        }</span>
}

func (m *CustomModel) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

func (m *CustomModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "q", "ctrl+c", "esc":<span class="cov0" title="0">
                        return m, tea.Quit</span>
                case "up", "k":<span class="cov0" title="0">
                        if m.selectedRow &gt; 0 </span><span class="cov0" title="0">{
                                m.selectedRow--
                        }</span>
                case "down", "j":<span class="cov0" title="0">
                        pageData := m.table.GetPage(m.currentPage)
                        if m.selectedRow &lt; len(pageData)-1 </span><span class="cov0" title="0">{
                                m.selectedRow++
                        }</span>
                case "left", "h":<span class="cov0" title="0">
                        if m.currentPage &gt; 0 </span><span class="cov0" title="0">{
                                m.currentPage--
                                m.selectedRow = 0
                        }</span>
                case "right", "l":<span class="cov0" title="0">
                        if m.currentPage &lt; m.table.GetTotalPages()-1 </span><span class="cov0" title="0">{
                                m.currentPage++
                                m.selectedRow = 0
                        }</span>
                case "1", "2", "3", "4", "5", "6":<span class="cov0" title="0">
                        // Sort by column
                        colIndex := int(msg.String()[0] - '1')
                        if colIndex &lt; len(m.table.Columns) </span><span class="cov0" title="0">{
                                if m.table.SortBy == colIndex </span><span class="cov0" title="0">{
                                        if !m.table.SortDesc </span><span class="cov0" title="0">{
                                                m.table.SortByColumn(colIndex, true)
                                        }</span> else<span class="cov0" title="0"> {
                                                m.table.ClearSort()
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        m.table.SortByColumn(colIndex, false)
                                }</span>
                                <span class="cov0" title="0">m.currentPage = 0
                                m.selectedRow = 0</span>
                        }
                }
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (m *CustomModel) View() string <span class="cov0" title="0">{
        // Custom rendering using the headless table data
        var b strings.Builder

        // Custom header
        headerStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("#FFFFFF")).
                Background(lipgloss.Color("#7D4CDB")).
                Padding(0, 2)

        b.WriteString(headerStyle.Render("🚀 Task Management Dashboard"))
        b.WriteString("\n\n")

        // Render table headers
        headerRow := ""
        for i, col := range m.table.Columns </span><span class="cov0" title="0">{
                header := col.Header
                if m.table.SortBy == i </span><span class="cov0" title="0">{
                        if m.table.SortDesc </span><span class="cov0" title="0">{
                                header += " ↓"
                        }</span> else<span class="cov0" title="0"> {
                                header += " ↑"
                        }</span>
                }

                <span class="cov0" title="0">cellStyle := lipgloss.NewStyle().
                        Width(col.Width).
                        Bold(true).
                        Foreground(lipgloss.Color("#000000")).
                        Background(lipgloss.Color("#E6E6FA")).
                        Padding(0, 1)

                headerRow += cellStyle.Render(header) + " "</span>
        }
        <span class="cov0" title="0">b.WriteString(headerRow)
        b.WriteString("\n")

        // Render data rows
        pageData := m.table.GetPage(m.currentPage)
        for rowIndex, row := range pageData </span><span class="cov0" title="0">{
                rowStr := ""
                isSelected := rowIndex == m.selectedRow

                for colIndex, cell := range row.Cells </span><span class="cov0" title="0">{
                        if colIndex &gt;= len(m.table.Columns) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">col := m.table.Columns[colIndex]
                        value := col.Formatter(cell.Value)

                        cellStyle := lipgloss.NewStyle().
                                Width(col.Width).
                                Padding(0, 1)

                        if isSelected </span><span class="cov0" title="0">{
                                cellStyle = cellStyle.
                                        Background(lipgloss.Color("#7D4CDB")).
                                        Foreground(lipgloss.Color("#FFFFFF")).
                                        Bold(true)
                        }</span> else<span class="cov0" title="0"> {
                                cellStyle = cellStyle.
                                        Background(lipgloss.Color("#F8F8FF"))
                        }</span>

                        <span class="cov0" title="0">rowStr += cellStyle.Render(value) + " "</span>
                }

                <span class="cov0" title="0">b.WriteString(rowStr)
                b.WriteString("\n")</span>
        }

        // Custom status bar
        <span class="cov0" title="0">b.WriteString("\n")
        statusStyle := lipgloss.NewStyle().
                Italic(true).
                Foreground(lipgloss.Color("#666666"))

        totalPages := m.table.GetTotalPages()
        status := fmt.Sprintf("Page %d of %d | %d total tasks | Use 1-6 to sort, h/l for pages, k/j for rows, q to quit",
                m.currentPage+1, totalPages, m.table.TotalRows)

        if m.table.SortBy &gt;= 0 </span><span class="cov0" title="0">{
                sortDir := "ascending"
                if m.table.SortDesc </span><span class="cov0" title="0">{
                        sortDir = "descending"
                }</span>
                <span class="cov0" title="0">status += fmt.Sprintf(" | Sorted by %s (%s)",
                        m.table.Columns[m.table.SortBy].Header, sortDir)</span>
        }

        <span class="cov0" title="0">b.WriteString(statusStyle.Render(status))

        return b.String()</span>
}

func main() <span class="cov0" title="0">{
        model := NewCustomModel()
        p := tea.NewProgram(model)
        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "log"

        "github.com/anurag-roy/bubbletable/components"
        "github.com/anurag-roy/bubbletable/renderer"
        "github.com/anurag-roy/bubbletable/table"
        tea "github.com/charmbracelet/bubbletea"
)

// Employee represents a sample employee struct with table tags
type Employee struct {
        ID         int     `table:"ID,sortable,width:5"`
        Name       string  `table:"Name,sortable,width:20"`
        Department string  `table:"Department,sortable,width:15"`
        Salary     float64 `table:"Salary,sortable,width:12,format:currency"`
        StartDate  string  `table:"Start Date,sortable,width:12,format:date"`
        Active     bool    `table:"Active,sortable,width:8"`
}

func main() <span class="cov0" title="0">{
        // Sample employee data demonstrating the library with the same data as the original app
        employees := []Employee{
                {1, "Alice Johnson", "Engineering", 75000.0, "2021-01-15", true},
                {2, "Bob Smith", "Marketing", 65000.0, "2020-03-20", true},
                {3, "Charlie Brown", "Sales", 55000.0, "2019-11-10", false},
                {4, "Diana Prince", "Engineering", 85000.0, "2021-06-01", true},
                {5, "Edward Norton", "Finance", 70000.0, "2020-08-15", true},
                {6, "Fiona Apple", "Design", 68000.0, "2021-02-28", true},
                {7, "George Lucas", "Engineering", 95000.0, "2018-12-01", true},
                {8, "Helen Troy", "HR", 62000.0, "2020-09-15", true},
                {9, "Ivan Drago", "Sales", 58000.0, "2019-07-20", true},
                {10, "Julia Roberts", "Marketing", 72000.0, "2021-04-10", true},
                {11, "Kevin Hart", "Engineering", 78000.0, "2020-11-25", true},
                {12, "Luna Lovegood", "Design", 64000.0, "2021-01-30", true},
                {13, "Mike Tyson", "Operations", 66000.0, "2020-05-12", true},
                {14, "Nancy Drew", "Legal", 88000.0, "2019-03-08", true},
                {15, "Oscar Wilde", "Marketing", 69000.0, "2020-10-22", false},
                {16, "Penny Lane", "Design", 67000.0, "2021-03-12", true},
                {17, "Quincy Jones", "Operations", 73000.0, "2020-07-08", true},
                {18, "Rachel Green", "Marketing", 71000.0, "2019-09-25", true},
                {19, "Steve Jobs", "Engineering", 120000.0, "2018-06-15", false},
                {20, "Tina Turner", "Sales", 59000.0, "2020-11-30", true},
                {21, "Uma Thurman", "Legal", 92000.0, "2019-04-18", true},
                {22, "Victor Hugo", "Finance", 74000.0, "2020-12-05", true},
                {23, "Wendy Darling", "HR", 64000.0, "2021-02-14", true},
                {24, "Xavier Woods", "Engineering", 81000.0, "2020-08-22", true},
                {25, "Yoda Master", "Operations", 95000.0, "2018-10-10", true},
                {26, "Zoe Saldana", "Design", 69000.0, "2021-01-08", true},
                {27, "Aaron Paul", "Sales", 61000.0, "2019-12-16", true},
                {28, "Bella Swan", "Marketing", 68000.0, "2020-09-11", true},
                {29, "Clark Kent", "Engineering", 87000.0, "2019-07-04", true},
                {30, "Daisy Miller", "HR", 63000.0, "2021-04-22", true},
                {31, "Ethan Hunt", "Operations", 79000.0, "2020-06-18", true},
                {32, "Faith Hill", "Legal", 89000.0, "2019-08-14", true},
                {33, "Goku Son", "Engineering", 98000.0, "2018-11-27", true},
                {34, "Hermione Granger", "Finance", 76000.0, "2020-10-09", true},
                {35, "Indiana Jones", "Operations", 82000.0, "2019-05-03", false},
                {36, "Jessica Alba", "Design", 70000.0, "2021-01-21", true},
                {37, "Kermit Frog", "Marketing", 65000.0, "2020-07-15", true},
                {38, "Lara Croft", "Engineering", 83000.0, "2019-09-08", true},
                {39, "Mario Bros", "Operations", 77000.0, "2020-12-12", true},
                {40, "Neo Anderson", "Engineering", 99000.0, "2018-08-19", true},
                {41, "Olivia Pope", "Legal", 94000.0, "2019-06-25", true},
                {42, "Peter Parker", "Engineering", 75000.0, "2020-11-03", true},
                {43, "Queen Elsa", "Design", 72000.0, "2021-02-07", true},
                {44, "Robin Hood", "Sales", 58000.0, "2019-10-29", true},
                {45, "Sherlock Holmes", "Legal", 96000.0, "2018-12-24", true},
                {46, "Tony Stark", "Engineering", 150000.0, "2018-05-11", true},
                {47, "Violet Parr", "Design", 66000.0, "2021-03-28", true},
                {48, "Wonder Woman", "Operations", 88000.0, "2019-02-17", true},
                {49, "Xena Warrior", "Sales", 62000.0, "2020-08-06", true},
                {50, "Yuki Tanaka", "Finance", 75000.0, "2021-01-13", true},
        }

        // Create table model using the new BubbleTable library API
        // This demonstrates the same functionality as the original app but with the new library
        tableModel := components.NewTable(employees).
                WithPageSize(10).                 // Set page size
                WithTheme(renderer.DefaultTheme). // Use default theme (same look as original)
                WithSorting(true).                // Enable sorting
                WithSearch(true).                 // Enable search
                WithOnSelect(func(row table.Row) </span><span class="cov0" title="0">{
                        // Optional: Handle row selection events
                        log.Printf("Selected employee: %s", row.Cells[1].Value) // Name is at index 1
                }</span>).
                WithOnSort(func(columnIndex int, desc bool) <span class="cov0" title="0">{
                        // Optional: Handle sort events
                        direction := "ascending"
                        if desc </span><span class="cov0" title="0">{
                                direction = "descending"
                        }</span>
                        <span class="cov0" title="0">log.Printf("Sorted by column %d (%s)", columnIndex, direction)</span>
                }).
                WithOnSearch(func(term string) <span class="cov0" title="0">{
                        // Optional: Handle search events
                        if term != "" </span><span class="cov0" title="0">{
                                log.Printf("Searching for: %s", term)
                        }</span>
                })

        // Create and run the Bubble Tea program
        // Same user experience as the original app, but now powered by the reusable library
        <span class="cov0" title="0">p := tea.NewProgram(tableModel, tea.WithAltScreen())
        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package renderer

import (
        "fmt"
        "strings"

        "github.com/anurag-roy/bubbletable/table"
)

// TableRenderer handles rendering tables with proper styling and layout
type TableRenderer struct {
        terminalWidth  int
        terminalHeight int
        theme          Theme
}

// NewTableRenderer creates a new table renderer with the default theme
func NewTableRenderer(width, height int) *TableRenderer <span class="cov8" title="1">{
        return &amp;TableRenderer{
                terminalWidth:  width,
                terminalHeight: height,
                theme:          DefaultTheme,
        }
}</span>

// NewTableRendererWithTheme creates a new table renderer with a custom theme
func NewTableRendererWithTheme(width, height int, theme Theme) *TableRenderer <span class="cov8" title="1">{
        return &amp;TableRenderer{
                terminalWidth:  width,
                terminalHeight: height,
                theme:          theme,
        }
}</span>

// SetTheme updates the renderer's theme
func (r *TableRenderer) SetTheme(theme Theme) <span class="cov8" title="1">{
        r.theme = theme
}</span>

// UpdateSize updates the terminal dimensions
func (r *TableRenderer) UpdateSize(width, height int) <span class="cov8" title="1">{
        r.terminalWidth = width
        r.terminalHeight = height
}</span>

// RenderTable renders a complete table with headers, data, and status
func (r *TableRenderer) RenderTable(tbl *table.Table, currentPage int, selectedRow int) string <span class="cov8" title="1">{
        if tbl == nil </span><span class="cov8" title="1">{
                return "No table data available"
        }</span>

        // Use nearly full terminal width - only subtract 2 for minimal border
        <span class="cov8" title="1">availableWidth := r.terminalWidth - 2
        if availableWidth &lt; 30 </span><span class="cov0" title="0">{
                availableWidth = 30 // Minimum reasonable width
        }</span>

        // Adjust column widths to use full available space
        <span class="cov8" title="1">adjustedColumns := r.distributeColumnWidths(tbl.Columns, availableWidth)

        // Build table components
        var tableRows []string

        // Header row with sort indicators
        headerRow := r.buildTableRow(adjustedColumns, func(i int, col table.Column) string </span><span class="cov8" title="1">{
                headerText := col.Header

                // Add sort indicator if this column is currently sorted
                sortIndicator := ""
                if tbl.SortBy == i </span><span class="cov8" title="1">{
                        if tbl.SortDesc </span><span class="cov8" title="1">{
                                sortIndicator = "↓"
                        }</span> else<span class="cov8" title="1"> {
                                sortIndicator = "↑"
                        }</span>
                }

                // Calculate available space for header text
                <span class="cov8" title="1">availableWidth := col.Width
                if sortIndicator != "" </span><span class="cov8" title="1">{
                        availableWidth -= 2 // Reserve space for " " + arrow
                }</span>

                // Truncate header text if needed to make room for sort indicator
                <span class="cov8" title="1">truncatedHeader := headerText
                if len(headerText) &gt; availableWidth </span><span class="cov0" title="0">{
                        truncatedHeader = r.truncateText(headerText, availableWidth)
                }</span>

                // Combine header text and sort indicator, right-aligned
                <span class="cov8" title="1">finalHeader := truncatedHeader
                if sortIndicator != "" </span><span class="cov8" title="1">{
                        padding := col.Width - len(truncatedHeader) - len(sortIndicator)
                        if padding &gt; 0 </span><span class="cov8" title="1">{
                                finalHeader += strings.Repeat(" ", padding) + sortIndicator
                        }</span> else<span class="cov0" title="0"> {
                                finalHeader += sortIndicator
                        }</span>
                }

                <span class="cov8" title="1">return r.theme.Header.Width(col.Width).Render(finalHeader)</span>
        })
        <span class="cov8" title="1">tableRows = append(tableRows, headerRow)

        // Separator row
        separatorRow := r.buildSeparatorRow(adjustedColumns)
        tableRows = append(tableRows, separatorRow)

        // Data rows
        pageData := tbl.GetPage(currentPage)
        for rowIndex, row := range pageData </span><span class="cov8" title="1">{
                isSelected := rowIndex == selectedRow

                dataRow := r.buildTableRow(adjustedColumns, func(colIndex int, col table.Column) string </span><span class="cov8" title="1">{
                        cellValue := ""
                        var cellVal interface{}
                        if colIndex &lt; len(row.Cells) </span><span class="cov8" title="1">{
                                cell := row.Cells[colIndex]
                                cellVal = cell.Value
                                // Use the column's formatter
                                cellValue = col.Formatter(cell.Value)
                        }</span>

                        <span class="cov8" title="1">content := r.truncateText(cellValue, col.Width)

                        // Use custom renderer if available
                        if col.Renderer != nil </span><span class="cov8" title="1">{
                                content = col.Renderer(cellVal, isSelected)
                                content = r.truncateText(content, col.Width)
                        }</span>

                        <span class="cov8" title="1">if isSelected </span><span class="cov8" title="1">{
                                return r.theme.SelectedRow.Width(col.Width).Render(content)
                        }</span>
                        <span class="cov8" title="1">return r.theme.Cell.Width(col.Width).Render(content)</span>
                })

                <span class="cov8" title="1">tableRows = append(tableRows, dataRow)</span>
        }

        // Join all table content
        <span class="cov8" title="1">tableContent := strings.Join(tableRows, "\n")

        return tableContent</span>
}

// distributeColumnWidths distributes available width across columns intelligently
func (r *TableRenderer) distributeColumnWidths(columns []table.Column, availableWidth int) []table.Column <span class="cov8" title="1">{
        if len(columns) == 0 </span><span class="cov0" title="0">{
                return columns
        }</span>

        <span class="cov8" title="1">adjusted := make([]table.Column, len(columns))
        copy(adjusted, columns)

        // Account for separators between columns
        separatorWidth := len(columns) - 1
        contentWidth := availableWidth - separatorWidth

        // Ensure minimum content width
        if contentWidth &lt; len(columns)*5 </span><span class="cov8" title="1">{
                contentWidth = len(columns) * 5
        }</span>

        // Calculate ideal width per column
        <span class="cov8" title="1">baseWidth := contentWidth / len(columns)
        remainder := contentWidth % len(columns)

        // Distribute width, giving extra to first few columns
        for i := range adjusted </span><span class="cov8" title="1">{
                adjusted[i].Width = baseWidth
                if i &lt; remainder </span><span class="cov8" title="1">{
                        adjusted[i].Width++
                }</span>

                // Ensure minimum width
                <span class="cov8" title="1">if adjusted[i].Width &lt; 5 </span><span class="cov0" title="0">{
                        adjusted[i].Width = 5
                }</span>
        }

        <span class="cov8" title="1">return adjusted</span>
}

// buildTableRow builds a table row using the provided cell renderer function
func (r *TableRenderer) buildTableRow(columns []table.Column, cellRenderer func(int, table.Column) string) string <span class="cov8" title="1">{
        var cells []string
        for i, col := range columns </span><span class="cov8" title="1">{
                cells = append(cells, cellRenderer(i, col))
        }</span>
        <span class="cov8" title="1">return strings.Join(cells, "│")</span>
}

// buildSeparatorRow builds a separator row between header and data
func (r *TableRenderer) buildSeparatorRow(columns []table.Column) string <span class="cov8" title="1">{
        var separators []string
        for _, col := range columns </span><span class="cov8" title="1">{
                separator := strings.Repeat("─", col.Width+2) // +2 for padding
                separators = append(separators, separator)
        }</span>
        <span class="cov8" title="1">return strings.Join(separators, "┼")</span>
}

// renderStatusLine renders the status line with page information
func (r *TableRenderer) renderStatusLine(tbl *table.Table, currentPage int) string <span class="cov0" title="0">{
        if tbl == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">totalPages := tbl.GetTotalPages()
        startRow := currentPage*tbl.PageSize + 1
        endRow := startRow + len(tbl.GetPage(currentPage)) - 1

        status := fmt.Sprintf("Page %d of %d | Rows %d-%d of %d | Page Size: %d",
                currentPage+1, totalPages, startRow, endRow, tbl.TotalRows, tbl.PageSize)

        // Add sort information
        if tbl.SortBy &gt;= 0 &amp;&amp; tbl.SortBy &lt; len(tbl.Columns) </span><span class="cov0" title="0">{
                sortDir := "asc"
                if tbl.SortDesc </span><span class="cov0" title="0">{
                        sortDir = "desc"
                }</span>
                <span class="cov0" title="0">status += fmt.Sprintf(" | Sorted by %s (%s)", tbl.Columns[tbl.SortBy].Header, sortDir)</span>
        }

        <span class="cov0" title="0">return r.theme.Status.Render(status)</span>
}

// truncateText truncates text to fit within the specified width
func (r *TableRenderer) truncateText(text string, width int) string <span class="cov8" title="1">{
        if len(text) &lt;= width </span><span class="cov8" title="1">{
                return text
        }</span>

        <span class="cov8" title="1">if width &lt;= 3 </span><span class="cov8" title="1">{
                return text[:width]
        }</span>

        <span class="cov8" title="1">return text[:width-3] + "..."</span>
}

// GetOptimalPageSize calculates the optimal page size based on terminal height
func (r *TableRenderer) GetOptimalPageSize() int <span class="cov8" title="1">{
        // Reserve space for header, separator, status, and some padding
        reservedLines := 10
        availableLines := r.terminalHeight - reservedLines

        if availableLines &lt; 5 </span><span class="cov0" title="0">{
                return 5 // Minimum page size
        }</span>

        <span class="cov8" title="1">return availableLines</span>
}

// GetMaxTableHeight returns the maximum height for table content
func (r *TableRenderer) GetMaxTableHeight() int <span class="cov8" title="1">{
        return r.terminalHeight - 5 // Reserve space for status and padding
}</span>

// GetTableCapacity returns how many rows can fit in the current terminal
func (r *TableRenderer) GetTableCapacity() int <span class="cov0" title="0">{
        return r.GetOptimalPageSize()
}</span>

// CalculateColumnWidths calculates optimal column widths based on content
func (r *TableRenderer) CalculateColumnWidths(tbl *table.Table, maxSampleRows int) []table.Column <span class="cov0" title="0">{
        if tbl == nil || len(tbl.Columns) == 0 </span><span class="cov0" title="0">{
                return []table.Column{}
        }</span>

        <span class="cov0" title="0">columns := make([]table.Column, len(tbl.Columns))
        copy(columns, tbl.Columns)

        // Sample up to maxSampleRows to determine optimal widths
        sampleSize := len(tbl.Rows)
        if sampleSize &gt; maxSampleRows </span><span class="cov0" title="0">{
                sampleSize = maxSampleRows
        }</span>

        // Calculate max width needed for each column
        <span class="cov0" title="0">for i, col := range columns </span><span class="cov0" title="0">{
                maxWidth := len(col.Header) // Start with header width

                // Check sample data
                for j := 0; j &lt; sampleSize; j++ </span><span class="cov0" title="0">{
                        if i &lt; len(tbl.Rows[j].Cells) </span><span class="cov0" title="0">{
                                cellValue := col.Formatter(tbl.Rows[j].Cells[i].Value)
                                if len(cellValue) &gt; maxWidth </span><span class="cov0" title="0">{
                                        maxWidth = len(cellValue)
                                }</span>
                        }
                }

                // Set reasonable bounds
                <span class="cov0" title="0">if maxWidth &lt; 5 </span><span class="cov0" title="0">{
                        maxWidth = 5
                }</span>
                <span class="cov0" title="0">if maxWidth &gt; 50 </span><span class="cov0" title="0">{
                        maxWidth = 50
                }</span>

                <span class="cov0" title="0">columns[i].Width = maxWidth</span>
        }

        <span class="cov0" title="0">return columns</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package renderer

import "github.com/charmbracelet/lipgloss"

// Theme represents a complete styling theme for tables
type Theme struct {
        Name        string
        Header      lipgloss.Style
        Cell        lipgloss.Style
        SelectedRow lipgloss.Style
        Border      lipgloss.Style
        Status      lipgloss.Style
        Search      lipgloss.Style
}

// Predefined themes
var (
        // DefaultTheme is a clean, professional look
        DefaultTheme = Theme{
                Name: "Default",
                Header: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#282A36")).
                        Background(lipgloss.Color("#C4A9F4")).
                        Bold(true).
                        Padding(0, 1),
                Cell: lipgloss.NewStyle().
                        Padding(0, 1),
                SelectedRow: lipgloss.NewStyle().
                        Background(lipgloss.Color("#44475A")).
                        Foreground(lipgloss.Color("#F8F8F2")).
                        Padding(0, 1),
                Border: lipgloss.NewStyle().
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(lipgloss.Color("#874BFD")),
                Status: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#6272A4")).
                        Italic(true),
                Search: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFB86C")).
                        Background(lipgloss.Color("#282A36")).
                        Padding(0, 1),
        }

        // DraculaTheme is based on the popular Dracula color scheme
        DraculaTheme = Theme{
                Name: "Dracula",
                Header: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#282A36")).
                        Background(lipgloss.Color("#BD93F9")).
                        Bold(true).
                        Padding(0, 1),
                Cell: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#F8F8F2")).
                        Padding(0, 1),
                SelectedRow: lipgloss.NewStyle().
                        Background(lipgloss.Color("#6272A4")).
                        Foreground(lipgloss.Color("#F8F8F2")).
                        Bold(true).
                        Padding(0, 1),
                Border: lipgloss.NewStyle().
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(lipgloss.Color("#BD93F9")),
                Status: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#6272A4")).
                        Italic(true),
                Search: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#50FA7B")).
                        Background(lipgloss.Color("#44475A")).
                        Padding(0, 1),
        }

        // MonokaiTheme is inspired by the Monokai color scheme
        MonokaiTheme = Theme{
                Name: "Monokai",
                Header: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#F8F8F2")).
                        Background(lipgloss.Color("#E6DB74")).
                        Bold(true).
                        Padding(0, 1),
                Cell: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#F8F8F2")).
                        Padding(0, 1),
                SelectedRow: lipgloss.NewStyle().
                        Background(lipgloss.Color("#75715E")).
                        Foreground(lipgloss.Color("#F8F8F2")).
                        Padding(0, 1),
                Border: lipgloss.NewStyle().
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(lipgloss.Color("#A6E22E")),
                Status: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#75715E")).
                        Italic(true),
                Search: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FD971F")).
                        Background(lipgloss.Color("#49483E")).
                        Padding(0, 1),
        }

        // GithubTheme is inspired by GitHub's interface
        GithubTheme = Theme{
                Name: "GitHub",
                Header: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#24292e")).
                        Background(lipgloss.Color("#f6f8fa")).
                        Bold(true).
                        Padding(0, 1),
                Cell: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#24292e")).
                        Padding(0, 1),
                SelectedRow: lipgloss.NewStyle().
                        Background(lipgloss.Color("#0366d6")).
                        Foreground(lipgloss.Color("#ffffff")).
                        Padding(0, 1),
                Border: lipgloss.NewStyle().
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(lipgloss.Color("#e1e4e8")),
                Status: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#586069")).
                        Italic(true),
                Search: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#0366d6")).
                        Background(lipgloss.Color("#f1f8ff")).
                        Padding(0, 1),
        }

        // TerminalTheme is a minimalist black and white theme
        TerminalTheme = Theme{
                Name: "Terminal",
                Header: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#000000")).
                        Background(lipgloss.Color("#ffffff")).
                        Bold(true).
                        Padding(0, 1),
                Cell: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#ffffff")).
                        Padding(0, 1),
                SelectedRow: lipgloss.NewStyle().
                        Background(lipgloss.Color("#ffffff")).
                        Foreground(lipgloss.Color("#000000")).
                        Padding(0, 1),
                Border: lipgloss.NewStyle().
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(lipgloss.Color("#ffffff")),
                Status: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#808080")).
                        Italic(true),
                Search: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#000000")).
                        Background(lipgloss.Color("#ffffff")).
                        Padding(0, 1),
        }

        // SolarizedDarkTheme is based on the Solarized Dark color scheme
        SolarizedDarkTheme = Theme{
                Name: "Solarized Dark",
                Header: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#002b36")).
                        Background(lipgloss.Color("#268bd2")).
                        Bold(true).
                        Padding(0, 1),
                Cell: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#839496")).
                        Padding(0, 1),
                SelectedRow: lipgloss.NewStyle().
                        Background(lipgloss.Color("#073642")).
                        Foreground(lipgloss.Color("#93a1a1")).
                        Padding(0, 1),
                Border: lipgloss.NewStyle().
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(lipgloss.Color("#586e75")),
                Status: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#586e75")).
                        Italic(true),
                Search: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#b58900")).
                        Background(lipgloss.Color("#073642")).
                        Padding(0, 1),
        }

        // SolarizedLightTheme is based on the Solarized Light color scheme
        SolarizedLightTheme = Theme{
                Name: "Solarized Light",
                Header: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#fdf6e3")).
                        Background(lipgloss.Color("#268bd2")).
                        Bold(true).
                        Padding(0, 1),
                Cell: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#657b83")).
                        Padding(0, 1),
                SelectedRow: lipgloss.NewStyle().
                        Background(lipgloss.Color("#eee8d5")).
                        Foreground(lipgloss.Color("#586e75")).
                        Padding(0, 1),
                Border: lipgloss.NewStyle().
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(lipgloss.Color("#93a1a1")),
                Status: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#93a1a1")).
                        Italic(true),
                Search: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#b58900")).
                        Background(lipgloss.Color("#eee8d5")).
                        Padding(0, 1),
        }
)

// GetAllThemes returns a slice of all available themes
func GetAllThemes() []Theme <span class="cov8" title="1">{
        return []Theme{
                DefaultTheme,
                DraculaTheme,
                MonokaiTheme,
                GithubTheme,
                TerminalTheme,
                SolarizedDarkTheme,
                SolarizedLightTheme,
        }
}</span>

// GetThemeByName returns a theme by name, or DefaultTheme if not found
func GetThemeByName(name string) Theme <span class="cov8" title="1">{
        themes := GetAllThemes()
        for _, theme := range themes </span><span class="cov8" title="1">{
                if theme.Name == name </span><span class="cov8" title="1">{
                        return theme
                }</span>
        }
        <span class="cov8" title="1">return DefaultTheme</span>
}

// CustomizeTheme creates a new theme based on an existing theme with custom overrides
func CustomizeTheme(base Theme, name string, customizations map[string]lipgloss.Style) Theme <span class="cov0" title="0">{
        theme := base
        theme.Name = name

        if style, ok := customizations["header"]; ok </span><span class="cov0" title="0">{
                theme.Header = style
        }</span>
        <span class="cov0" title="0">if style, ok := customizations["cell"]; ok </span><span class="cov0" title="0">{
                theme.Cell = style
        }</span>
        <span class="cov0" title="0">if style, ok := customizations["selected"]; ok </span><span class="cov0" title="0">{
                theme.SelectedRow = style
        }</span>
        <span class="cov0" title="0">if style, ok := customizations["border"]; ok </span><span class="cov0" title="0">{
                theme.Border = style
        }</span>
        <span class="cov0" title="0">if style, ok := customizations["status"]; ok </span><span class="cov0" title="0">{
                theme.Status = style
        }</span>
        <span class="cov0" title="0">if style, ok := customizations["search"]; ok </span><span class="cov0" title="0">{
                theme.Search = style
        }</span>

        <span class="cov0" title="0">return theme</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package table

import (
        "fmt"
        "reflect"
        "sort"
        "strconv"
        "strings"
        "time"
)

// DataType represents the type of data in a column
type DataType int

const (
        String DataType = iota
        Integer
        Float
        Date
        Boolean
)

// Formatter is a function that formats a value for display
type Formatter func(value interface{}) string

// CellRenderer is a function that renders a cell value with styling information
type CellRenderer func(value interface{}, selected bool) string

// Accessor is a function that extracts a value from a data row
type Accessor func(data interface{}) interface{}

// Column represents a table column with metadata and behavior
type Column struct {
        Key        string
        Header     string
        Type       DataType
        Width      int
        Sortable   bool
        Searchable bool
        Formatter  Formatter
        Renderer   CellRenderer
        Accessor   Accessor
}

// NewColumn creates a new column with the given key and header
func NewColumn(key, header string) *Column <span class="cov8" title="1">{
        return &amp;Column{
                Key:        key,
                Header:     header,
                Type:       String,
                Width:      15,
                Sortable:   true,
                Searchable: true,
                Formatter:  DefaultFormatter,
                Renderer:   nil,
                Accessor:   nil,
        }
}</span>

// WithType sets the column data type
func (c *Column) WithType(dataType DataType) *Column <span class="cov8" title="1">{
        c.Type = dataType
        return c
}</span>

// WithWidth sets the column display width
func (c *Column) WithWidth(width int) *Column <span class="cov8" title="1">{
        c.Width = width
        return c
}</span>

// WithSortable sets whether the column is sortable
func (c *Column) WithSortable(sortable bool) *Column <span class="cov8" title="1">{
        c.Sortable = sortable
        return c
}</span>

// WithSearchable sets whether the column is searchable
func (c *Column) WithSearchable(searchable bool) *Column <span class="cov8" title="1">{
        c.Searchable = searchable
        return c
}</span>

// WithFormatter sets a custom formatter for the column
func (c *Column) WithFormatter(formatter Formatter) *Column <span class="cov8" title="1">{
        c.Formatter = formatter
        return c
}</span>

// WithRenderer sets a custom renderer for the column
func (c *Column) WithRenderer(renderer CellRenderer) *Column <span class="cov0" title="0">{
        c.Renderer = renderer
        return c
}</span>

// WithAccessor sets a custom accessor function for the column
func (c *Column) WithAccessor(accessor Accessor) *Column <span class="cov0" title="0">{
        c.Accessor = accessor
        return c
}</span>

// Cell represents a single cell value with type information
type Cell struct {
        Value interface{}
        Type  DataType
}

// Row represents a table row
type Row struct {
        ID    int
        Cells []Cell
        Data  interface{} // Original data for custom accessors
}

// Table represents the complete table data structure
type Table struct {
        Columns       []Column
        Rows          []Row
        UnsortedOrder []Row // Store original row order for unsort functionality
        SortBy        int   // Column index for sorting (-1 if not sorted)
        SortDesc      bool  // Sort direction (true for descending)
        PageSize      int
        TotalRows     int
        originalData  []interface{} // Store original data for re-processing
}

// New creates a new empty table
func New() *Table <span class="cov8" title="1">{
        return &amp;Table{
                Columns:       make([]Column, 0),
                Rows:          make([]Row, 0),
                UnsortedOrder: make([]Row, 0),
                SortBy:        -1,
                SortDesc:      false,
                PageSize:      10,
                TotalRows:     0,
                originalData:  make([]interface{}, 0),
        }
}</span>

// NewWithColumns creates a new table with predefined columns
func NewWithColumns(columns []Column) *Table <span class="cov8" title="1">{
        table := New()
        table.Columns = columns
        return table
}</span>

// WithColumns sets the table columns (builder pattern)
func (t *Table) WithColumns(columns []Column) *Table <span class="cov0" title="0">{
        t.Columns = columns
        return t
}</span>

// WithPageSize sets the page size (builder pattern)
func (t *Table) WithPageSize(pageSize int) *Table <span class="cov8" title="1">{
        t.PageSize = pageSize
        return t
}</span>

// WithData sets the table data from a slice of any type (builder pattern)
func (t *Table) WithData(data interface{}) *Table <span class="cov8" title="1">{
        t.SetData(data)
        return t
}</span>

// SetData populates the table with data from a slice of any type
func (t *Table) SetData(data interface{}) error <span class="cov8" title="1">{
        v := reflect.ValueOf(data)
        if v.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                return fmt.Errorf("data must be a slice")
        }</span>

        // Clear existing data
        <span class="cov8" title="1">t.Rows = make([]Row, 0)
        t.UnsortedOrder = make([]Row, 0)
        t.TotalRows = 0
        t.originalData = make([]interface{}, 0)

        // If no columns are defined, try to infer them from the data
        if len(t.Columns) == 0 &amp;&amp; v.Len() &gt; 0 </span><span class="cov8" title="1">{
                firstItem := v.Index(0).Interface()
                columns, err := t.inferColumnsFromStruct(firstItem)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">t.Columns = columns</span>
        }

        // Process each item in the slice
        <span class="cov8" title="1">for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                item := v.Index(i).Interface()
                t.originalData = append(t.originalData, item)

                err := t.addRowFromData(item, i)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error processing row %d: %v", i, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// addRowFromData adds a row from arbitrary data
func (t *Table) addRowFromData(data interface{}, id int) error <span class="cov8" title="1">{
        cells := make([]Cell, len(t.Columns))

        for i, col := range t.Columns </span><span class="cov8" title="1">{
                var value interface{}
                var err error

                if col.Accessor != nil </span><span class="cov0" title="0">{
                        // Use custom accessor
                        value = col.Accessor(data)
                }</span> else<span class="cov8" title="1"> {
                        // Try to extract value based on column key
                        value, err = t.extractValueFromData(data, col.Key)
                        if err != nil </span><span class="cov0" title="0">{
                                value = ""
                        }</span>
                }

                <span class="cov8" title="1">cells[i] = Cell{
                        Value: value,
                        Type:  col.Type,
                }</span>
        }

        <span class="cov8" title="1">row := Row{
                ID:    id,
                Cells: cells,
                Data:  data,
        }

        t.Rows = append(t.Rows, row)
        t.UnsortedOrder = append(t.UnsortedOrder, row)
        t.TotalRows++

        return nil</span>
}

// extractValueFromData extracts a value from data using reflection
func (t *Table) extractValueFromData(data interface{}, key string) (interface{}, error) <span class="cov8" title="1">{
        v := reflect.ValueOf(data)

        // Handle maps
        if v.Kind() == reflect.Map </span><span class="cov8" title="1">{
                mapValue := v.MapIndex(reflect.ValueOf(key))
                if mapValue.IsValid() </span><span class="cov8" title="1">{
                        return mapValue.Interface(), nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("key %s not found in map", key)</span>
        }

        // Handle structs
        <span class="cov8" title="1">if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">if v.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                field := v.FieldByName(key)
                if field.IsValid() </span><span class="cov8" title="1">{
                        return field.Interface(), nil
                }</span>

                // Try case-insensitive search
                <span class="cov0" title="0">t := v.Type()
                for i := 0; i &lt; t.NumField(); i++ </span><span class="cov0" title="0">{
                        fieldType := t.Field(i)
                        if strings.EqualFold(fieldType.Name, key) </span><span class="cov0" title="0">{
                                return v.Field(i).Interface(), nil
                        }</span>
                }

                <span class="cov0" title="0">return nil, fmt.Errorf("field %s not found in struct", key)</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("cannot extract value from type %T", data)</span>
}

// inferColumnsFromStruct infers columns from a struct using reflection and struct tags
func (t *Table) inferColumnsFromStruct(data interface{}) ([]Column, error) <span class="cov8" title="1">{
        v := reflect.ValueOf(data)
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        <span class="cov8" title="1">if v.Kind() == reflect.Map </span><span class="cov0" title="0">{
                return t.inferColumnsFromMap(data)
        }</span>

        <span class="cov8" title="1">if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot infer columns from type %T", data)
        }</span>

        <span class="cov8" title="1">var columns []Column
        structType := v.Type()

        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov8" title="1">{
                field := structType.Field(i)

                // Skip unexported fields
                if !field.IsExported() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">col := Column{
                        Key:        field.Name,
                        Header:     field.Name,
                        Sortable:   true,
                        Searchable: true,
                        Formatter:  DefaultFormatter,
                }

                // Parse struct tag for configuration
                if tag := field.Tag.Get("table"); tag != "" </span><span class="cov8" title="1">{
                        col = t.parseStructTag(col, tag)
                }</span>

                // Infer type from Go type
                <span class="cov8" title="1">col.Type = t.inferDataType(field.Type)

                // Set default width based on type
                col.Width = t.getDefaultWidth(col.Type)

                columns = append(columns, col)</span>
        }

        <span class="cov8" title="1">return columns, nil</span>
}

// inferColumnsFromMap infers columns from a map
func (t *Table) inferColumnsFromMap(data interface{}) ([]Column, error) <span class="cov0" title="0">{
        v := reflect.ValueOf(data)
        if v.Kind() != reflect.Map </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected map, got %T", data)
        }</span>

        <span class="cov0" title="0">var columns []Column
        for _, key := range v.MapKeys() </span><span class="cov0" title="0">{
                keyStr := fmt.Sprintf("%v", key.Interface())
                value := v.MapIndex(key)

                col := Column{
                        Key:        keyStr,
                        Header:     keyStr,
                        Sortable:   true,
                        Searchable: true,
                        Formatter:  DefaultFormatter,
                        Type:       t.inferDataType(value.Type()),
                }

                col.Width = t.getDefaultWidth(col.Type)
                columns = append(columns, col)
        }</span>

        <span class="cov0" title="0">return columns, nil</span>
}

// parseStructTag parses struct tag for column configuration
func (t *Table) parseStructTag(col Column, tag string) Column <span class="cov8" title="1">{
        parts := strings.Split(tag, ",")

        // First part is the header name
        if len(parts) &gt; 0 &amp;&amp; parts[0] != "" </span><span class="cov8" title="1">{
                col.Header = parts[0]
        }</span>

        // Parse additional options
        <span class="cov8" title="1">for i := 1; i &lt; len(parts); i++ </span><span class="cov8" title="1">{
                part := strings.TrimSpace(parts[i])

                switch </span>{
                case part == "sortable":<span class="cov8" title="1">
                        col.Sortable = true</span>
                case part == "!sortable":<span class="cov8" title="1">
                        col.Sortable = false</span>
                case part == "searchable":<span class="cov0" title="0">
                        col.Searchable = true</span>
                case part == "!searchable":<span class="cov0" title="0">
                        col.Searchable = false</span>
                case strings.HasPrefix(part, "width:"):<span class="cov8" title="1">
                        if width, err := strconv.Atoi(strings.TrimPrefix(part, "width:")); err == nil </span><span class="cov8" title="1">{
                                col.Width = width
                        }</span>
                case strings.HasPrefix(part, "format:"):<span class="cov8" title="1">
                        format := strings.TrimPrefix(part, "format:")
                        col.Formatter = t.getFormatterByName(format)</span>
                }
        }

        <span class="cov8" title="1">return col</span>
}

// inferDataType infers DataType from Go reflect.Type
func (t *Table) inferDataType(goType reflect.Type) DataType <span class="cov8" title="1">{
        switch goType.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                return Integer</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return Float</span>
        case reflect.Bool:<span class="cov8" title="1">
                return Boolean</span>
        case reflect.String:<span class="cov8" title="1">
                return String</span>
        default:<span class="cov0" title="0">
                // Check if it's a time.Time
                if goType == reflect.TypeOf(time.Time{}) </span><span class="cov0" title="0">{
                        return Date
                }</span>
                <span class="cov0" title="0">return String</span>
        }
}

// getDefaultWidth returns default width for a data type
func (t *Table) getDefaultWidth(dataType DataType) int <span class="cov8" title="1">{
        switch dataType </span>{
        case Integer:<span class="cov8" title="1">
                return 8</span>
        case Float:<span class="cov8" title="1">
                return 10</span>
        case Boolean:<span class="cov8" title="1">
                return 8</span>
        case Date:<span class="cov0" title="0">
                return 12</span>
        default:<span class="cov8" title="1">
                return 15</span>
        }
}

// getFormatterByName returns a formatter by name
func (t *Table) getFormatterByName(name string) Formatter <span class="cov8" title="1">{
        switch name </span>{
        case "currency":<span class="cov8" title="1">
                return CurrencyFormatter</span>
        case "date":<span class="cov8" title="1">
                return DateFormatter</span>
        case "percent":<span class="cov0" title="0">
                return PercentFormatter</span>
        default:<span class="cov0" title="0">
                return DefaultFormatter</span>
        }
}

// AddRow adds a new row to the table with explicit values
func (t *Table) AddRow(values ...interface{}) error <span class="cov0" title="0">{
        if len(values) != len(t.Columns) </span><span class="cov0" title="0">{
                return fmt.Errorf("expected %d values, got %d", len(t.Columns), len(values))
        }</span>

        <span class="cov0" title="0">cells := make([]Cell, len(values))
        for i, value := range values </span><span class="cov0" title="0">{
                cells[i] = Cell{
                        Value: value,
                        Type:  t.Columns[i].Type,
                }
        }</span>

        <span class="cov0" title="0">row := Row{
                ID:    t.TotalRows,
                Cells: cells,
                Data:  values, // Store the raw values as data
        }

        t.Rows = append(t.Rows, row)
        t.UnsortedOrder = append(t.UnsortedOrder, row)
        t.TotalRows++
        return nil</span>
}

// GetPage returns a slice of rows for the given page number (0-indexed)
func (t *Table) GetPage(pageNum int) []Row <span class="cov8" title="1">{
        start := pageNum * t.PageSize
        end := start + t.PageSize

        if start &gt;= len(t.Rows) </span><span class="cov8" title="1">{
                return []Row{}
        }</span>

        <span class="cov8" title="1">if end &gt; len(t.Rows) </span><span class="cov8" title="1">{
                end = len(t.Rows)
        }</span>

        <span class="cov8" title="1">return t.Rows[start:end]</span>
}

// GetTotalPages returns the total number of pages
func (t *Table) GetTotalPages() int <span class="cov8" title="1">{
        if t.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov8" title="1">if len(t.Rows) == 0 </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return (len(t.Rows) + t.PageSize - 1) / t.PageSize</span>
}

// SortByColumn sorts the table by the specified column
func (t *Table) SortByColumn(columnIndex int, descending bool) error <span class="cov8" title="1">{
        if columnIndex &lt; 0 || columnIndex &gt;= len(t.Columns) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid column index: %d", columnIndex)
        }</span>

        <span class="cov8" title="1">if !t.Columns[columnIndex].Sortable </span><span class="cov0" title="0">{
                return fmt.Errorf("column %s is not sortable", t.Columns[columnIndex].Header)
        }</span>

        <span class="cov8" title="1">t.SortBy = columnIndex
        t.SortDesc = descending

        sort.Slice(t.Rows, func(i, j int) bool </span><span class="cov8" title="1">{
                cellI := t.Rows[i].Cells[columnIndex]
                cellJ := t.Rows[j].Cells[columnIndex]

                result := compareCells(cellI, cellJ)
                if descending </span><span class="cov8" title="1">{
                        return result &gt; 0
                }</span>
                <span class="cov8" title="1">return result &lt; 0</span>
        })

        <span class="cov8" title="1">return nil</span>
}

// ClearSort clears any active sorting and restores original order
func (t *Table) ClearSort() <span class="cov8" title="1">{
        t.SortBy = -1
        t.SortDesc = false
        // Restore original order
        t.Rows = make([]Row, len(t.UnsortedOrder))
        copy(t.Rows, t.UnsortedOrder)
}</span>

// Filter returns a new table with rows matching the search term
func (t *Table) Filter(searchTerm string) *Table <span class="cov8" title="1">{
        if searchTerm == "" </span><span class="cov0" title="0">{
                return t
        }</span>

        <span class="cov8" title="1">filtered := NewWithColumns(t.Columns)
        filtered.PageSize = t.PageSize
        searchTerm = strings.ToLower(searchTerm)

        for _, row := range t.Rows </span><span class="cov8" title="1">{
                if t.rowMatchesSearch(row, searchTerm) </span><span class="cov8" title="1">{
                        filtered.Rows = append(filtered.Rows, row)
                        filtered.UnsortedOrder = append(filtered.UnsortedOrder, row)
                        filtered.TotalRows++
                }</span>
        }

        // Preserve sort state from original table
        <span class="cov8" title="1">filtered.SortBy = t.SortBy
        filtered.SortDesc = t.SortDesc

        return filtered</span>
}

// rowMatchesSearch checks if a row contains the search term in any searchable cell
func (t *Table) rowMatchesSearch(row Row, searchTerm string) bool <span class="cov8" title="1">{
        for i, cell := range row.Cells </span><span class="cov8" title="1">{
                if i &lt; len(t.Columns) &amp;&amp; t.Columns[i].Searchable </span><span class="cov8" title="1">{
                        cellStr := strings.ToLower(t.formatCellValue(cell, i))
                        if strings.Contains(cellStr, searchTerm) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// formatCellValue formats a cell value using the column's formatter
func (t *Table) formatCellValue(cell Cell, columnIndex int) string <span class="cov8" title="1">{
        if columnIndex &lt; len(t.Columns) &amp;&amp; t.Columns[columnIndex].Formatter != nil </span><span class="cov8" title="1">{
                return t.Columns[columnIndex].Formatter(cell.Value)
        }</span>
        <span class="cov0" title="0">return DefaultFormatter(cell.Value)</span>
}

// GetCellValue returns the formatted value of a cell
func (t *Table) GetCellValue(rowIndex, columnIndex int) string <span class="cov0" title="0">{
        if rowIndex &lt; 0 || rowIndex &gt;= len(t.Rows) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if columnIndex &lt; 0 || columnIndex &gt;= len(t.Columns) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">cell := t.Rows[rowIndex].Cells[columnIndex]
        return t.formatCellValue(cell, columnIndex)</span>
}

// GetColumnNames returns the headers of all columns
func (t *Table) GetColumnNames() []string <span class="cov0" title="0">{
        names := make([]string, len(t.Columns))
        for i, col := range t.Columns </span><span class="cov0" title="0">{
                names[i] = col.Header
        }</span>
        <span class="cov0" title="0">return names</span>
}

// compareCells compares two cells for sorting purposes
func compareCells(a, b Cell) int <span class="cov8" title="1">{
        switch a.Type </span>{
        case String:<span class="cov8" title="1">
                aStr := fmt.Sprintf("%v", a.Value)
                bStr := fmt.Sprintf("%v", b.Value)
                return strings.Compare(strings.ToLower(aStr), strings.ToLower(bStr))</span>

        case Integer:<span class="cov8" title="1">
                aInt, _ := strconv.Atoi(fmt.Sprintf("%v", a.Value))
                bInt, _ := strconv.Atoi(fmt.Sprintf("%v", b.Value))
                return aInt - bInt</span>

        case Float:<span class="cov8" title="1">
                aFloat, _ := strconv.ParseFloat(fmt.Sprintf("%v", a.Value), 64)
                bFloat, _ := strconv.ParseFloat(fmt.Sprintf("%v", b.Value), 64)
                if aFloat &lt; bFloat </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aFloat &gt; bFloat </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>

        case Boolean:<span class="cov8" title="1">
                aBool := fmt.Sprintf("%v", a.Value) == "true"
                bBool := fmt.Sprintf("%v", b.Value) == "true"
                if aBool == bBool </span><span class="cov0" title="0">{
                        return 0
                }</span> else<span class="cov8" title="1"> if aBool </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return -1</span>

        case Date:<span class="cov0" title="0">
                aTime, aErr := parseDate(a.Value)
                bTime, bErr := parseDate(b.Value)
                if aErr != nil || bErr != nil </span><span class="cov0" title="0">{
                        // Fall back to string comparison if date parsing fails
                        aStr := fmt.Sprintf("%v", a.Value)
                        bStr := fmt.Sprintf("%v", b.Value)
                        return strings.Compare(aStr, bStr)
                }</span>
                <span class="cov0" title="0">if aTime.Before(bTime) </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aTime.After(bTime) </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>

        default:<span class="cov0" title="0">
                aStr := fmt.Sprintf("%v", a.Value)
                bStr := fmt.Sprintf("%v", b.Value)
                return strings.Compare(strings.ToLower(aStr), strings.ToLower(bStr))</span>
        }
}

// parseDate parses various date formats
func parseDate(value interface{}) (time.Time, error) <span class="cov0" title="0">{
        str := fmt.Sprintf("%v", value)

        // Try common date formats
        formats := []string{
                "2006-01-02",
                "2006-01-02 15:04:05",
                "01/02/2006",
                "01-02-2006",
                "2006/01/02",
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if t, err := time.Parse(format, str); err == nil </span><span class="cov0" title="0">{
                        return t, nil
                }</span>
        }

        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("unable to parse date: %s", str)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package table

import (
        "fmt"
        "time"
)

// DefaultFormatter is the default formatter that converts any value to string
func DefaultFormatter(value interface{}) string <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case bool:<span class="cov8" title="1">
                if v </span><span class="cov8" title="1">{
                        return "true"
                }</span>
                <span class="cov8" title="1">return "false"</span>
        case float64:<span class="cov8" title="1">
                return fmt.Sprintf("%.2f", v)</span>
        case float32:<span class="cov8" title="1">
                return fmt.Sprintf("%.2f", v)</span>
        case time.Time:<span class="cov8" title="1">
                return v.Format("2006-01-02")</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", value)</span>
        }
}

// CurrencyFormatter formats numeric values as currency
func CurrencyFormatter(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case float64:<span class="cov8" title="1">
                return fmt.Sprintf("$%.2f", v)</span>
        case float32:<span class="cov8" title="1">
                return fmt.Sprintf("$%.2f", v)</span>
        case int:<span class="cov8" title="1">
                return fmt.Sprintf("$%d.00", v)</span>
        case int64:<span class="cov8" title="1">
                return fmt.Sprintf("$%d.00", v)</span>
        default:<span class="cov8" title="1">
                // Try to convert to float
                if str := fmt.Sprintf("%v", value); str != "" </span><span class="cov8" title="1">{
                        return "$" + str
                }</span>
                <span class="cov0" title="0">return "$0.00"</span>
        }
}

// PercentFormatter formats numeric values as percentages
func PercentFormatter(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case float64:<span class="cov8" title="1">
                return fmt.Sprintf("%.1f%%", v*100)</span>
        case float32:<span class="cov8" title="1">
                return fmt.Sprintf("%.1f%%", v*100)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v%%", value)</span>
        }
}

// DateFormatter formats date values consistently
func DateFormatter(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case time.Time:<span class="cov8" title="1">
                return v.Format("2006-01-02")</span>
        case string:<span class="cov8" title="1">
                // Try to parse the string as a date
                if t, err := time.Parse("2006-01-02", v); err == nil </span><span class="cov8" title="1">{
                        return t.Format("2006-01-02")
                }</span>
                <span class="cov8" title="1">if t, err := time.Parse("01/02/2006", v); err == nil </span><span class="cov8" title="1">{
                        return t.Format("2006-01-02")
                }</span>
                <span class="cov8" title="1">if t, err := time.Parse("2006-01-02 15:04:05", v); err == nil </span><span class="cov8" title="1">{
                        return t.Format("2006-01-02")
                }</span>
                <span class="cov8" title="1">return v</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", value)</span>
        }
}

// TimeFormatter formats time values with time included
func TimeFormatter(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case time.Time:<span class="cov8" title="1">
                return v.Format("2006-01-02 15:04:05")</span>
        case string:<span class="cov8" title="1">
                // Try to parse and reformat
                if t, err := time.Parse("2006-01-02 15:04:05", v); err == nil </span><span class="cov8" title="1">{
                        return t.Format("2006-01-02 15:04:05")
                }</span>
                <span class="cov8" title="1">return v</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", value)</span>
        }
}

// BooleanFormatter formats boolean values with custom true/false strings
func BooleanFormatter(trueStr, falseStr string) Formatter <span class="cov8" title="1">{
        return func(value interface{}) string </span><span class="cov8" title="1">{
                switch v := value.(type) </span>{
                case bool:<span class="cov8" title="1">
                        if v </span><span class="cov8" title="1">{
                                return trueStr
                        }</span>
                        <span class="cov8" title="1">return falseStr</span>
                case string:<span class="cov8" title="1">
                        if v == "true" || v == "1" || v == "yes" </span><span class="cov8" title="1">{
                                return trueStr
                        }</span>
                        <span class="cov8" title="1">return falseStr</span>
                default:<span class="cov8" title="1">
                        return falseStr</span>
                }
        }
}

// NumberWithCommasFormatter formats large numbers with comma separators
func NumberWithCommasFormatter(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return addCommas(fmt.Sprintf("%d", v))</span>
        case int64:<span class="cov8" title="1">
                return addCommas(fmt.Sprintf("%d", v))</span>
        case float64:<span class="cov8" title="1">
                return addCommas(fmt.Sprintf("%.0f", v))</span>
        case float32:<span class="cov8" title="1">
                return addCommas(fmt.Sprintf("%.0f", v))</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", value)</span>
        }
}

// addCommas adds comma separators to a numeric string
func addCommas(s string) string <span class="cov8" title="1">{
        if len(s) &lt;= 3 </span><span class="cov8" title="1">{
                return s
        }</span>

        // Handle negative numbers
        <span class="cov8" title="1">negative := false
        if s[0] == '-' </span><span class="cov8" title="1">{
                negative = true
                s = s[1:]
        }</span>

        <span class="cov8" title="1">n := len(s)
        result := make([]byte, 0, n+n/3)

        for i, char := range []byte(s) </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; (n-i)%3 == 0 </span><span class="cov8" title="1">{
                        result = append(result, ',')
                }</span>
                <span class="cov8" title="1">result = append(result, char)</span>
        }

        <span class="cov8" title="1">if negative </span><span class="cov8" title="1">{
                return "-" + string(result)
        }</span>
        <span class="cov8" title="1">return string(result)</span>
}

// TruncateFormatter creates a formatter that truncates strings to a maximum length
func TruncateFormatter(maxLength int) Formatter <span class="cov8" title="1">{
        return func(value interface{}) string </span><span class="cov8" title="1">{
                str := fmt.Sprintf("%v", value)
                if len(str) &lt;= maxLength </span><span class="cov8" title="1">{
                        return str
                }</span>
                <span class="cov8" title="1">if maxLength &lt;= 3 </span><span class="cov8" title="1">{
                        return str[:maxLength]
                }</span>
                <span class="cov8" title="1">return str[:maxLength-3] + "..."</span>
        }
}

// PrefixFormatter creates a formatter that adds a prefix to values
func PrefixFormatter(prefix string) Formatter <span class="cov8" title="1">{
        return func(value interface{}) string </span><span class="cov8" title="1">{
                return prefix + fmt.Sprintf("%v", value)
        }</span>
}

// SuffixFormatter creates a formatter that adds a suffix to values
func SuffixFormatter(suffix string) Formatter <span class="cov8" title="1">{
        return func(value interface{}) string </span><span class="cov8" title="1">{
                return fmt.Sprintf("%v", value) + suffix
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
